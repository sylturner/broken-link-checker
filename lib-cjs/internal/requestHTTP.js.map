{"version":3,"sources":["../../lib/internal/requestHTTP.js"],"names":["ERROR_EVENT","REDIRECT_EVENT","RESPONSE_EVENT","REQUEST_EVENT","createRequest","url","auth","method","options","retry","Promise","resolve","reject","headers","userAgent","redirects","rejectUnauthorized","retries","throwHttpErrors","on","request","setTimeout","destroy","stream","push","simplifyResponse","response","HEAD_METHOD","retryHeadFail","retryHeadCodes","includes","status","GET_METHOD","statusCode","statusMessage","statusText","URL","stringifyAuth","password","username","cache","isURL","lenient","TypeError","BLC_INVALID","promise","toLowerCase","cacheResponses","cachedPromise","then","set","forEach","redirect","i","subsequentRedirects","slice","catch","error"],"mappings":"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","sourcesContent":["import {BLC_INVALID} from \"./reasons\";\nimport {GET_METHOD, HEAD_METHOD} from \"./methods\";\nimport isURL from \"isurl\";\nimport {stream as streamHTTP} from \"got\";\n//import tunnel from \"auto-tunnel\";\n\n\n\nconst ERROR_EVENT = \"error\";\nconst REDIRECT_EVENT = \"redirect\";\nconst RESPONSE_EVENT = \"response\";\nconst REQUEST_EVENT = \"request\";\n\n\n\n/**\n * Create an HTTP request.\n * @param {URL} url\n * @param {object} auth\n * @param {string} method\n * @param {object} options\n * @param {boolean} [retry]\n * @returns {Promise<object>}\n */\nconst createRequest = (url, auth, method, options, retry=false) => new Promise((resolve, reject) =>\n{\n\tconst headers = { \"user-agent\": options.userAgent };\n\tconst redirects = [];\n\n\tstreamHTTP(url,\n\t{\n\t\t//agent: tunnel(url, { proxyHeaders:headers }),\n\t\t//auth: stringifyAuth(url, auth),\n\t\theaders,\n\t\tmethod,\n\t\trejectUnauthorized: false,  // accept self-signed SSL certificates\n\t\tretries: 0,  // explicit; they're already disabled for streams\n    throwHttpErrors: false,\n\t})\n  .on(REQUEST_EVENT, request => {\n    setTimeout(() => {\n      request.destroy();\n    }, 10000);\n  })\n  .on(ERROR_EVENT, reject)\n\t.on(REDIRECT_EVENT, stream => redirects.push( simplifyResponse(stream) ))\n\t.on(RESPONSE_EVENT, stream =>\n\t{\n    const response = simplifyResponse(stream, redirects);\n\n\t\tif (!retry && method===HEAD_METHOD && options.retryHeadFail && options.retryHeadCodes.includes(response.status))\n\t\t{\n\t\t\t// Retry potentially broken server with GET_METHOD\n\t\t\tresolve( createRequest(url, auth, GET_METHOD, options, true) );\n\t\t}\n\t\telse if (method===GET_METHOD && response.status>=200 && response.status<=299)\n\t\t{\n\t\t\tresolve({ response, stream });\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresolve({ response });\n\t\t}\n\t});\n});\n\n\n\n/**\n * Create a simple response object from that of the \"http\" module.\n * @param {object|Stream} response\n * @param {Array<object>} [redirects]\n * @returns {object}\n * @todo add response time -- https://github.com/sindresorhus/got/issues/874\n */\nconst simplifyResponse = ({headers, statusCode, statusMessage, url}, redirects) =>\n({\n\theaders,\n\tstatus: statusCode,\n\tstatusText: statusMessage,\n\turl: new URL(url),\n\t...(redirects && {redirects})\n});\n\n\n\n/**\n * Convert an HTTP authentication URL or object into a string.\n * @param {URL} url\n * @param {object} auth\n * @returns {string}\n */\nconst stringifyAuth = (url, auth) =>\n{\n\tif (url.password!==\"\" || url.username!==\"\")\n\t{\n\t\treturn `${url.username}:${url.password}`;\n\t}\n\telse if (auth.password!==\"\" || auth.username!==\"\")\n\t{\n\t\treturn `${auth.username}:${auth.password}`;\n\t}\n};\n\n\n\n/**\n * Create an HTTP request and optionally cache the response.\n * @param {URL} url\n * @param {object} auth\n * @param {string} method\n * @param {URLCache} cache\n * @param {object} options\n * @throws {TypeError} non-URL\n * @returns {Promise<object>}\n * @todo use `Promise.try()` instead of `async`\n */\nexport default async (url, auth, method, cache, options) =>\n{\n\tif (!isURL.lenient(url))\n  {\n\t\tthrow new TypeError(BLC_INVALID);\n\t}\n\telse\n\t{\n\t\tconst promise = createRequest(url, auth, method.toLowerCase(), options);\n\n\t\tif (options.cacheResponses)\n\t\t{\n\t\t\tconst cachedPromise = promise\n\t\t\t.then(({response}) =>\n\t\t\t{\n\t\t\t\t// Replace cached promise\n\t\t\t\tcache.set(url, response);\n\n\t\t\t\t// Any final redirect\n\t\t\t\tcache.set(response.url, response);\n\n\t\t\t\t// Any intermediary redirects\n\t\t\t\tresponse.redirects.forEach((redirect, i) =>\n\t\t\t\t{\n\t\t\t\t\tconst subsequentRedirects = response.redirects.slice(i + 1);\n\n\t\t\t\t\tcache.set(redirect.url, {...response, redirects:subsequentRedirects});\n\t\t\t\t});\n\n\t\t\t\treturn response;\n\t\t\t})\n\t\t\t.catch(error => error);  // pass-through\n\t\t}\n\n\t\treturn promise;\n\t}\n};\n"],"file":"requestHTTP.js"}