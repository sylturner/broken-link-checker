{"version":3,"sources":["../../lib/internal/requestHTTP.js"],"names":["ERROR_EVENT","REDIRECT_EVENT","RESPONSE_EVENT","createRequest","url","auth","method","options","retry","Promise","resolve","reject","headers","userAgent","redirects","agent","proxyHeaders","rejectUnauthorized","retries","throwHttpErrors","on","stream","push","simplifyResponse","response","HEAD_METHOD","retryHeadFail","retryHeadCodes","includes","status","GET_METHOD","statusCode","statusMessage","statusText","URL","stringifyAuth","password","username","cache","isURL","lenient","TypeError","BLC_INVALID","promise","toLowerCase","cacheResponses","cachedPromise","then","set","forEach","redirect","i","subsequentRedirects","slice","catch","error"],"mappings":"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","sourcesContent":["import {BLC_INVALID} from \"./reasons\";\nimport {GET_METHOD, HEAD_METHOD} from \"./methods\";\nimport isURL from \"isurl\";\nimport {stream as streamHTTP} from \"got\";\nimport tunnel from \"auto-tunnel\";\n\n\n\nconst ERROR_EVENT = \"error\";\nconst REDIRECT_EVENT = \"redirect\";\nconst RESPONSE_EVENT = \"response\";\n\n\n\n/**\n * Create an HTTP request.\n * @param {URL} url\n * @param {object} auth\n * @param {string} method\n * @param {object} options\n * @param {boolean} [retry]\n * @returns {Promise<object>}\n */\nconst createRequest = (url, auth, method, options, retry=false) => new Promise((resolve, reject) =>\n{\n\tconst headers = { \"user-agent\":options.userAgent };\n\tconst redirects = [];\n\n\tstreamHTTP(url,\n\t{\n\t\tagent: tunnel(url, { proxyHeaders:headers }),\n\t\t//auth: stringifyAuth(url, auth),\n\t\theaders,\n\t\tmethod,\n\t\trejectUnauthorized: false,  // accept self-signed SSL certificates\n\t\tretries: 0,  // explicit; they're already disabled for streams\n\t\tthrowHttpErrors: false\n\t})\n\t.on(ERROR_EVENT, reject)\n\t.on(REDIRECT_EVENT, stream => redirects.push( simplifyResponse(stream) ))\n\t.on(RESPONSE_EVENT, stream =>\n\t{\n\t\tconst response = simplifyResponse(stream, redirects);\n\n\t\tif (!retry && method===HEAD_METHOD && options.retryHeadFail && options.retryHeadCodes.includes(response.status))\n\t\t{\n\t\t\t// Retry potentially broken server with GET_METHOD\n\t\t\tresolve( createRequest(url, auth, GET_METHOD, options, true) );\n\t\t}\n\t\telse if (method===GET_METHOD && response.status>=200 && response.status<=299)\n\t\t{\n\t\t\tresolve({ response, stream });\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresolve({ response });\n\t\t}\n\t});\n});\n\n\n\n/**\n * Create a simple response object from that of the \"http\" module.\n * @param {object|Stream} response\n * @param {Array<object>} [redirects]\n * @returns {object}\n * @todo add response time -- https://github.com/sindresorhus/got/issues/874\n */\nconst simplifyResponse = ({headers, statusCode, statusMessage, url}, redirects) =>\n({\n\theaders,\n\tstatus: statusCode,\n\tstatusText: statusMessage,\n\turl: new URL(url),\n\t...(redirects && {redirects})\n});\n\n\n\n/**\n * Convert an HTTP authentication URL or object into a string.\n * @param {URL} url\n * @param {object} auth\n * @returns {string}\n */\nconst stringifyAuth = (url, auth) =>\n{\n\tif (url.password!==\"\" || url.username!==\"\")\n\t{\n\t\treturn `${url.username}:${url.password}`;\n\t}\n\telse if (auth.password!==\"\" || auth.username!==\"\")\n\t{\n\t\treturn `${auth.username}:${auth.password}`;\n\t}\n};\n\n\n\n/**\n * Create an HTTP request and optionally cache the response.\n * @param {URL} url\n * @param {object} auth\n * @param {string} method\n * @param {URLCache} cache\n * @param {object} options\n * @throws {TypeError} non-URL\n * @returns {Promise<object>}\n * @todo use `Promise.try()` instead of `async`\n */\nexport default async (url, auth, method, cache, options) =>\n{\n\tif (!isURL.lenient(url))\n  {\n\t\tthrow new TypeError(BLC_INVALID);\n\t}\n\telse\n\t{\n\t\tconst promise = createRequest(url, auth, method.toLowerCase(), options);\n\n\t\tif (options.cacheResponses)\n\t\t{\n\t\t\tconst cachedPromise = promise\n\t\t\t.then(({response}) =>\n\t\t\t{\n\t\t\t\t// Replace cached promise\n\t\t\t\tcache.set(url, response);\n\n\t\t\t\t// Any final redirect\n\t\t\t\tcache.set(response.url, response);\n\n\t\t\t\t// Any intermediary redirects\n\t\t\t\tresponse.redirects.forEach((redirect, i) =>\n\t\t\t\t{\n\t\t\t\t\tconst subsequentRedirects = response.redirects.slice(i + 1);\n\n\t\t\t\t\tcache.set(redirect.url, {...response, redirects:subsequentRedirects});\n\t\t\t\t});\n\n\t\t\t\treturn response;\n\t\t\t})\n\t\t\t.catch(error => error);  // pass-through\n\t\t}\n\n\t\treturn promise;\n\t}\n};\n"],"file":"requestHTTP.js"}