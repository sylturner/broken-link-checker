{"version":3,"sources":["../../lib/internal/checkLink.js"],"names":["checkHTTP","link","auth","cache","options","result","get","REBASED_URL","requestMethod","then","response","catch","error","console","log","copyResponseData","set","HTTP_RESPONSE_WAS_CACHED","cacheResponses","Error","break","code","status","mend","HTTP_RESPONSE","Link","TypeError","output","protocol","acceptedSchemes","undefined","JSON","parse"],"mappings":"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","sourcesContent":["import {cloneDeep} from \"lodash\";\n//import {join as joinPath} from \"path\";\nimport Link, {HTTP_RESPONSE, HTTP_RESPONSE_WAS_CACHED, REBASED_URL} from \"./Link\";\n//import {promises as fs} from \"fs\";\nimport requestHTTP from \"./requestHTTP\";\nimport URLRelation from \"url-relation\";\n\n//const {stat:statFile} = fs;\n\n\n\n/**\n * Check a link on the local file system.\n * @param {Link} link\n * @param {URLCache} cache\n * @param {object} options\n * @returns {Promise<Link>}\n */\n/*const checkFile = async (link, cache, options) =>\n{\n\ttry\n\t{\n\t\tconst {isFile} = await statFile(link.get(REBASED_URL).pathname);\n\n\t\tif (!isFile())\n\t\t{\n\t\t\t//throw new Error(\"ERRNOTFOUND\");\n\t\t}\n\n\t\tlink.mend();\n\t}\n\tcatch ({code})\n\t{\n\t\tlink.break(`ERRNO_${code}`);\n\t}\n\tfinally\n\t{\n\t\treturn link;\n\t}\n};*/\n\n\n\n/**\n * Check a link via HTTP.\n * @param {Link} link\n * @param {object} auth\n * @param {URLCache} cache\n * @param {object} options\n * @returns {Promise<Link>}\n */\nconst checkHTTP = async (link, auth, cache, options) =>\n{\n\tconst result = await requestHTTP(link.get(REBASED_URL), auth, options.requestMethod, cache, options)\n\t.then(({response}) => response)  // exclude any stream\n    .catch(error => error);\n  console.log(\"http result\", result)\n\n\tcopyResponseData(result, link, options);\n\n\tlink.set(HTTP_RESPONSE_WAS_CACHED, false);\n\n\treturn link;\n};\n\n\n\n/**\n * Copy data from a cached or uncached response into a Link.\n * @param {object|Error} response\n * @param {Link} link\n * @param {object} options\n */\nconst copyResponseData = (response, link, {cacheResponses}) =>\n{\n\tif (response instanceof Error)\n\t{\n\t\tlink.break(`ERRNO_${response.code}`);\n\t}\n\telse\n\t{\n\t\tif (response.status<200 || response.status>299)\n\t\t{\n\t\t\tlink.break(`HTTP_${response.status}`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlink.mend();\n\t\t}\n\n\t\tif (cacheResponses)\n\t\t{\n\t\t\t// Avoid potential mutations to cache\n\t\t\tresponse = cloneDeep(response);\n\t\t}\n\n\t\tlink.set(HTTP_RESPONSE, response);\n\t}\n};\n\n\n\n/**\n * Check a link's URL to see if it is broken or not.\n * @param {Link} link\n * @param {object} auth\n * @param {URLCache} cache\n * @param {object} options\n * @throws {TypeError} non-Link\n * @returns {Promise<Link>}\n */\nexport default async (link, auth, cache, options) =>\n{\n\tif (!(link instanceof Link))\n\t{\n\t\tthrow new TypeError(\"Invalid Link\");\n\t}\n\telse\n\t{\n\t\tlet output;\n\n\t\tif (!(link.get(REBASED_URL)?.protocol in options.acceptedSchemes))\n\t\t{\n\t\t\tlink.break(\"BLC_INVALID\");\n\t\t\toutput = link;\n\t\t}\n\t\telse if (options.cacheResponses)\n\t\t{\n\t\t\t// @todo different auths can have different responses\n\t\t\tconst result = await cache.get(link.get(REBASED_URL));\n\n      //console.log('--------------')\n      //console.log('cached result', result)\n      //console.log('--------------')\n\t\t\tif (result !== undefined && result !== null)\n\t\t\t{\n\t\t\t\tcopyResponseData(JSON.parse(result), link, options);\n\n\t\t\t\tlink.set(HTTP_RESPONSE_WAS_CACHED, true);\n\t\t\t\toutput = link;\n\t\t\t}\n\t\t}\n\n\t\tif (output)\n\t\t{\n\t\t\treturn output;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn checkHTTP(link, auth, cache, options);\n\t\t}\n\t}\n};\n"],"file":"checkLink.js"}