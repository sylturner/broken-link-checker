{"version":3,"sources":["../../lib/internal/checkLink.js"],"names":["checkHTTP","link","auth","cache","options","result","get","REBASED_URL","requestMethod","then","response","catch","error","copyResponseData","set","HTTP_RESPONSE_WAS_CACHED","cacheResponses","Error","break","code","status","mend","HTTP_RESPONSE","Link","TypeError","output","protocol","acceptedSchemes","undefined","JSON","parse"],"mappings":";;;;;;;AAAA;;AAEA;;AAEA;;AACA;;;;;;;;AAJA;AAEA;AAIA;;AAIA;;;;;;;;AAOA;;;;;;;;;;;;;;;;;;;;;;;AAyBA;;;;;;;;AAQA,MAAMA,SAAS,GAAG,OAAOC,IAAP,EAAaC,IAAb,EAAmBC,KAAnB,EAA0BC,OAA1B,KAClB;AACC,QAAMC,MAAM,GAAG,MAAM,0BAAYJ,IAAI,CAACK,GAAL,CAASC,iBAAT,CAAZ,EAAmCL,IAAnC,EAAyCE,OAAO,CAACI,aAAjD,EAAgEL,KAAhE,EAAuEC,OAAvE,EACpBK,IADoB,CACf,CAAC;AAACC,IAAAA;AAAD,GAAD,KAAgBA,QADD,EACY;AADZ,GAEpBC,KAFoB,CAEdC,KAAK,IAAIA,KAFK,CAArB;AAIAC,EAAAA,gBAAgB,CAACR,MAAD,EAASJ,IAAT,EAAeG,OAAf,CAAhB;AAEAH,EAAAA,IAAI,CAACa,GAAL,CAASC,8BAAT,EAAmC,KAAnC;AAEA,SAAOd,IAAP;AACA,CAXD;AAeA;;;;;;;;AAMA,MAAMY,gBAAgB,GAAG,CAACH,QAAD,EAAWT,IAAX,EAAiB;AAACe,EAAAA;AAAD,CAAjB,KACzB;AACC,MAAIN,QAAQ,YAAYO,KAAxB,EACA;AACChB,IAAAA,IAAI,CAACiB,KAAL,CAAY,SAAQR,QAAQ,CAACS,IAAK,EAAlC;AACA,GAHD,MAKA;AACC,QAAIT,QAAQ,CAACU,MAAT,GAAgB,GAAhB,IAAuBV,QAAQ,CAACU,MAAT,GAAgB,GAA3C,EACA;AACCnB,MAAAA,IAAI,CAACiB,KAAL,CAAY,QAAOR,QAAQ,CAACU,MAAO,EAAnC;AACA,KAHD,MAKA;AACCnB,MAAAA,IAAI,CAACoB,IAAL;AACA;;AAED,QAAIL,cAAJ,EACA;AACC;AACAN,MAAAA,QAAQ,GAAG,uBAAUA,QAAV,CAAX;AACA;;AAEDT,IAAAA,IAAI,CAACa,GAAL,CAASQ,mBAAT,EAAwBZ,QAAxB;AACA;AACD,CAzBD;AA6BA;;;;;;;;;;;eASe,OAAOT,IAAP,EAAaC,IAAb,EAAmBC,KAAnB,EAA0BC,OAA1B,KACf;AACC,MAAI,EAAEH,IAAI,YAAYsB,aAAlB,CAAJ,EACA;AACC,UAAM,IAAIC,SAAJ,CAAc,cAAd,CAAN;AACA,GAHD,MAKA;AAAA;;AACC,QAAIC,MAAJ;;AAEA,QAAI,EAAE,cAAAxB,IAAI,CAACK,GAAL,CAASC,iBAAT,yDAAuBmB,QAAvB,KAAmCtB,OAAO,CAACuB,eAA7C,CAAJ,EACA;AACC1B,MAAAA,IAAI,CAACiB,KAAL,CAAW,aAAX;AACAO,MAAAA,MAAM,GAAGxB,IAAT;AACA,KAJD,MAKK,IAAIG,OAAO,CAACY,cAAZ,EACL;AACC;AACA,YAAMX,MAAM,GAAG,MAAMF,KAAK,CAACG,GAAN,CAAUL,IAAI,CAACK,GAAL,CAASC,iBAAT,CAAV,CAArB,CAFD,CAII;AACA;AACA;;AACH,UAAIF,MAAM,KAAKuB,SAAX,IAAwBvB,MAAM,KAAK,IAAvC,EACA;AACCQ,QAAAA,gBAAgB,CAACgB,IAAI,CAACC,KAAL,CAAWzB,MAAX,CAAD,EAAqBJ,IAArB,EAA2BG,OAA3B,CAAhB;AAEAH,QAAAA,IAAI,CAACa,GAAL,CAASC,8BAAT,EAAmC,IAAnC;AACAU,QAAAA,MAAM,GAAGxB,IAAT;AACA;AACD;;AAED,QAAIwB,MAAJ,EACA;AACC,aAAOA,MAAP;AACA,KAHD,MAKA;AACC,aAAOzB,SAAS,CAACC,IAAD,EAAOC,IAAP,EAAaC,KAAb,EAAoBC,OAApB,CAAhB;AACA;AACD;AACD,C","sourcesContent":["import {cloneDeep} from \"lodash\";\n//import {join as joinPath} from \"path\";\nimport Link, {HTTP_RESPONSE, HTTP_RESPONSE_WAS_CACHED, REBASED_URL} from \"./Link\";\n//import {promises as fs} from \"fs\";\nimport requestHTTP from \"./requestHTTP\";\nimport URLRelation from \"url-relation\";\n\n//const {stat:statFile} = fs;\n\n\n\n/**\n * Check a link on the local file system.\n * @param {Link} link\n * @param {URLCache} cache\n * @param {object} options\n * @returns {Promise<Link>}\n */\n/*const checkFile = async (link, cache, options) =>\n{\n\ttry\n\t{\n\t\tconst {isFile} = await statFile(link.get(REBASED_URL).pathname);\n\n\t\tif (!isFile())\n\t\t{\n\t\t\t//throw new Error(\"ERRNOTFOUND\");\n\t\t}\n\n\t\tlink.mend();\n\t}\n\tcatch ({code})\n\t{\n\t\tlink.break(`ERRNO_${code}`);\n\t}\n\tfinally\n\t{\n\t\treturn link;\n\t}\n};*/\n\n\n\n/**\n * Check a link via HTTP.\n * @param {Link} link\n * @param {object} auth\n * @param {URLCache} cache\n * @param {object} options\n * @returns {Promise<Link>}\n */\nconst checkHTTP = async (link, auth, cache, options) =>\n{\n\tconst result = await requestHTTP(link.get(REBASED_URL), auth, options.requestMethod, cache, options)\n\t.then(({response}) => response)  // exclude any stream\n\t.catch(error => error);\n\n\tcopyResponseData(result, link, options);\n\n\tlink.set(HTTP_RESPONSE_WAS_CACHED, false);\n\n\treturn link;\n};\n\n\n\n/**\n * Copy data from a cached or uncached response into a Link.\n * @param {object|Error} response\n * @param {Link} link\n * @param {object} options\n */\nconst copyResponseData = (response, link, {cacheResponses}) =>\n{\n\tif (response instanceof Error)\n\t{\n\t\tlink.break(`ERRNO_${response.code}`);\n\t}\n\telse\n\t{\n\t\tif (response.status<200 || response.status>299)\n\t\t{\n\t\t\tlink.break(`HTTP_${response.status}`);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlink.mend();\n\t\t}\n\n\t\tif (cacheResponses)\n\t\t{\n\t\t\t// Avoid potential mutations to cache\n\t\t\tresponse = cloneDeep(response);\n\t\t}\n\n\t\tlink.set(HTTP_RESPONSE, response);\n\t}\n};\n\n\n\n/**\n * Check a link's URL to see if it is broken or not.\n * @param {Link} link\n * @param {object} auth\n * @param {URLCache} cache\n * @param {object} options\n * @throws {TypeError} non-Link\n * @returns {Promise<Link>}\n */\nexport default async (link, auth, cache, options) =>\n{\n\tif (!(link instanceof Link))\n\t{\n\t\tthrow new TypeError(\"Invalid Link\");\n\t}\n\telse\n\t{\n\t\tlet output;\n\n\t\tif (!(link.get(REBASED_URL)?.protocol in options.acceptedSchemes))\n\t\t{\n\t\t\tlink.break(\"BLC_INVALID\");\n\t\t\toutput = link;\n\t\t}\n\t\telse if (options.cacheResponses)\n\t\t{\n\t\t\t// @todo different auths can have different responses\n\t\t\tconst result = await cache.get(link.get(REBASED_URL));\n\n      //console.log('--------------')\n      //console.log('cached result', result)\n      //console.log('--------------')\n\t\t\tif (result !== undefined && result !== null)\n\t\t\t{\n\t\t\t\tcopyResponseData(JSON.parse(result), link, options);\n\n\t\t\t\tlink.set(HTTP_RESPONSE_WAS_CACHED, true);\n\t\t\t\toutput = link;\n\t\t\t}\n\t\t}\n\n\t\tif (output)\n\t\t{\n\t\t\treturn output;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn checkHTTP(link, auth, cache, options);\n\t\t}\n\t}\n};\n"],"file":"checkLink.js"}